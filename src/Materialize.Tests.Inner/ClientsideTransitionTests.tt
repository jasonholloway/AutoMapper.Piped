<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(ProjectDir)..\Materialize.SequenceMethods\bin\$(Configuration)\Materialize.SequenceMethods.dll" #>
<#@ assembly name="$(ProjectDir)..\Materialize\bin\Debug\Materialize.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Materialize.SequenceMethods" #>
<#@ import namespace="Materialize.Types" #>
<#@ output extension="cs" #>
using NUnit.Framework;
using System;
using System.Linq;


[TestFixture]
public class ClientsideTransitionTests 
{

	class Item {
		public int Int { get; private set; }

		public Item(int i) {
			Int = i;
		}
	}

	IQueryable<Item> Items { get; } = Enumerable.Range(25, 50).Select(i => new Item(i)).AsQueryable();

	
	public ClientsideTransitionTests() {
		//...
	}

<#foreach(var test in Tests) {#>
	[Test]
	public void <#=test.Name#>() {
		throw new NotImplementedException();
	}

<#}#>
}




<#+

static IEnumerable<Test> Tests = SeqMethodMap.Methods.Values.Select(m => new Test(m));





class Test 
{
	public string Name { get; private set; }
	public string Source { get; private set; }
	public string Statement {get; private set; }

    public Test(SeqMethod method) {
		Name = method.Name + "Test";
			
		Statement = "." + method.Qy.Name;		
    }

}




static string WriteArgValue(Type t) {	
	switch(t.GetNiceName()) {
		case "Int32":
			return "17";

		case "TSource":
		case "TAccumulate":
			return "Items.ElementAt(13)";
													
		case "Expression<Func<TSource, TSource, TSource>>":
		case "Expression<Func<TAccumulate, TSource, TAccumulate>>":
			return "(i, j) => new Item(i.Int + j.Int)";

		case "Expression<Func<TAccumulate, TResult>>":
			return "i => i";

		case "Expression<Func<TSource, Boolean>>":
			return "i => i.Int % 2 == 1";

		case "Expression<Func<TSource, Int32>>":		
		case "Expression<Func<TSource, Nullable<Int32>>>":
			return "i => i.Int * 3";
														
		case "Expression<Func<TSource, Single>>":
		case "Expression<Func<TSource, Nullable<Single>>>":
			return "i => i.Int * 3.5F";
														
		case "Expression<Func<TSource, Int64>>":		
		case "Expression<Func<TSource, Nullable<Int64>>>":
			return "i => i.Int * 13";
														
		case "Expression<Func<TSource, Decimal>>":		
		case "Expression<Func<TSource, Nullable<Decimal>>>":
			return "i => i.Int * 3.67";
																												
		case "Expression<Func<TSource, Double>>":		
		case "Expression<Func<TSource, Nullable<Double>>>":
			return "i => i.Int * 0.73";

		case "Expression<Func<TSource, TKey>>":
		case "Expression<Func<TOuter, TKey>>":
		case "Expression<Func<TInner, TKey>>":
			return "i => i.Int.ToString()";

		case "Expression<Func<TKey, IEnumerable<TElement>, TResult>>":
		case "Expression<Func<TKey, IEnumerable<TSource>, TResult>>":
			return "(k, r) => r.Last()";

		case "Expression<Func<TOuter, IEnumerable<TInner>, TResult>>":
			return "(o, r) => new Item(r.Last().Int + o.Int)";

		case "Expression<Func<TOuter, TInner, TResult>>":
			return "(o, i) => new Item(o.Int - i.Int * 3)";

		case "Expression<Func<TSource, TElement>>":
		case "Expression<Func<TSource, TResult>>":
			return "i => new Item(i.Int - 1)";

		case "Expression<Func<TSource, Int32, TResult>>":
			return "(s, i) => new Item(s.Int * i)";

		case "Expression<Func<TSource, IEnumerable<TResult>>>":
			return "i => Enumerable.Repeat(i, i.Int + 30)";

		case "Expression<Func<TSource, Int32, IEnumerable<TResult>>>":
			return "(s, i) => Enumerable.Repeat(s, i * 2)";

		case "Expression<Func<TSource, Int32, Boolean>>":
			return "(s, i) => s.Int + i < 10";
			 
		case "Expression<Func<TFirst, TSecond, TResult>>":
			return "(a, b) => new Item(a.Int * b.Int)";

		case "Expression<Func<TSource, IEnumerable<TCollection>>>":
		case "Expression<Func<TSource, Int32, IEnumerable<TCollection>>>":
			return "s => new[] { new List<Item>() }";

		case "Expression<Func<TSource, TCollection, TResult>>":
			return "(s, c) => s";
			 
		case "IQueryable<TSource>":
		case "IEnumerable<TSource>":
		case "IEnumerable<TInner>":
		case "IEnumerable<TSecond>":
			return "qySource.Reverse()";

		case "IEqualityComparer<TSource>":
			return "ItemComparer.Default";

		case "IEqualityComparer<TKey>":
			return "EqualityComparer<string>.Default";

		case "IComparer<TKey>":
			return "StringComparer.Ordinal";

		default:
			return "??????";
    }

}




#>