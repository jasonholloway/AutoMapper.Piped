<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Security" #>
<#@ output extension=".cs" #>
<#	
	var names = new HashSet<string>();

	var enMethods = typeof(Enumerable).GetMethods()
										.Where(m => m.DeclaringType == typeof(Enumerable))
										.Where(m => m.GetParameters().Any() && typeof(IEnumerable).IsAssignableFrom(m.GetParameters().First().ParameterType))
										.OrderBy(m => m.Name)
										.Select(m => new EnMethod(m, IndividuateName(names, m.Name)))
										.ToArray();
#>
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using Materialize.Types;

internal static partial class EnMethods 
{
<#
foreach(var m in enMethods) {
#>	///<summary>
	///<#=SecurityElement.Escape(m.Description)#>
	///</summary>
	public static readonly MethodInfo <#=m.Name#>;

<#
}
	#>
	
	static EnMethods() 
	{
<# foreach(var m in enMethods) {
	   
#>		<#=m.Name#> = Refl.Get<#=(m.Method.IsGenericMethodDefinition ? "Gen" : "")#>Method(() => <#=m.CallStatement#>);
<#
}#>
	}
} 

<#+
	class EnMethod { 
		public readonly MethodInfo Method;
		public readonly string Name;
		public readonly string Description;
		public readonly string CallStatement;


        public EnMethod(MethodInfo method, string name) {
			Method = method;
			Name = name;
			Description = BuildDescription();
			CallStatement = BuildCallStatement();
        }



		string BuildCallStatement() {
			var m = Method;
			var sb = new StringBuilder();

			sb.Append("Enumerable.");
			sb.Append(m.Name);
			
			var typeArgs = m.GetGenericArguments();

			if(typeArgs.Any()) {
				sb.Append("<");
				sb.Append(string.Join(", ", typeArgs.Select(t => "object")));
				sb.Append(">");
            }

			sb.Append("(");

			var paramParts = m.GetParameters()
								.Select(p => {
									var t = p.ParameterType;

									if(t.IsValueType) {
										return Activator.CreateInstance(t).ToString();
                                    }

									var cast = Regex.Replace(GetNiceTypeName(t), @"(T[A-Za-z]+)" , @"object");

									return "(" + cast + ")null";
								}); 

			sb.Append(string.Join(", ", paramParts));

			sb.Append(")");

			return sb.ToString();
        }




		string BuildDescription() {
			var typeArgs = Method.GetGenericArguments();			
			var pars = Method.GetParameters().Skip(1);

			return string.Format(
							"{0} qy.{1}<{2}>({3})",
							GetNiceTypeName(Method.ReturnType),
							Method.Name,
							string.Join(", ", typeArgs.Select(t => GetNiceTypeName(t))),
							string.Join(", ", pars.Select(p => string.Format("{0} {1}", GetNiceTypeName(p.ParameterType), p.Name)))
							);
        }



		public override string ToString() {
			return Description;
        }
	}


		
	static string IndividuateName(ISet<string> names,  string baseName) 
	{	
		for(int i = 1; true; i++) {
			var name = baseName + (i > 1 ? i.ToString() : "");

			if(!names.Contains(name)) {
				names.Add(name);
				return name;
            }
        }
    }



    
    static string GetNiceTypeName(Type type) 
    {
        if(type.IsGenericType) {
            var baseName = Regex.Match(type.Name, "(.*)`").Groups[1].Value;

            var sb = new StringBuilder(baseName);
            sb.Append("<");

            bool successor = false;

            foreach(var typeArg in type.GetGenericArguments()) {
                if(successor) {
                    sb.Append(", ");
                }

                sb.Append(GetNiceTypeName(typeArg));

                successor = true;
            }

            sb.Append(">");

            return sb.ToString();
        }
        else if(type.IsGenericTypeDefinition) {
            throw new NotImplementedException();
        }
        else {
            return type.Name;
        }
    }






#>