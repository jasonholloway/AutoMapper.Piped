using Materialize.Expressions;
using Materialize.Reify2.Compile;
using Materialize.Reify2.Mapping;
using Materialize.Reify2.Parameterize;
using Materialize.Reify2.Parse;
using Materialize.SourceRegimes;
using Materialize.Types;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

namespace Materialize.Reify2
{
    //Reifiables are mostly QueryProviders, serving ReifyQueries
    //As such, they orchestrate query-parsing, fetching and transformation, via a stack of modifiers.

    interface IReifiable : IQueryProvider
    { }


    class Reifiable<TElem> : IReifiable
    {
        ISourceRegimeProvider _regimeSourceProv;
        MapperSource _mapperWriterSource;
        MaterializeOptions _options;
        ISnooper _snoop;        
        IQueryable<TElem> _qySource;
        

        public Reifiable(
            IQueryable<TElem> sourceQuery, 
            ISourceRegimeProvider regimeSourceProv,
            MapperSource mapperWriterSource,
            MaterializeOptions options)
        {
            _qySource = sourceQuery;

            _regimeSourceProv = regimeSourceProv;
            _mapperWriterSource = mapperWriterSource;
            _options = options;
            _snoop = options.Snooper;
        }
        


        public IQueryable<TElement> CreateQuery<TElement>(Expression expression) 
        {
            return typeof(IOrderedQueryable).IsAssignableFrom(expression.Type)
                    ? new OrderedReifyQuery<TElement>(this, expression)
                    : new ReifyQuery<TElement>(this, expression);            
        }


        public IQueryable CreateQuery(Expression expression) {
            //Just delegate via refl to typed method...
            throw new NotImplementedException();
        }

                
        


        public TResult Execute<TResult>(Expression exQuery) 
        {
            if(!exQuery.Contains(_qySource.Expression)) {
                throw new InvalidOperationException("Bad query expression passed to Reifiable.Execute!");
            }

            _snoop?.Event("Incoming query", exQuery);
            
            var ctx = new ReifyContext(
                            _options.MappingEngine,
                            _options.SourceRegime ?? _regimeSourceProv.GetRegime(_qySource),
                            _mapperWriterSource,
                            _options.AllowClientSideFiltering ?? false,
                            _snoop);


            //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            //CACHEING HERE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                

            //surely need to canonicalize before cacheing, as we may parameterize more than just constants - eg members of constants
            //would make cache more effective. BUT injecting these in per-call opens up the gates of hell, so to speak: we can't
            //trust EF to take them. EF needs to take bare constants, rather than values derived from constants. This is indeed
            //what funcletizing does already.


            var reifier = ReifierFactory.Build(exQuery, ctx, _qySource.Expression);

            
            var result = (TResult)reifier.Execute(_qySource.Provider, exQuery);

            _snoop?.Event("Result", result);

            return result;
        }



        public object Execute(Expression expression) {
            //Just delegate via refl to typed method...
            throw new NotImplementedException();
        }
        

    }

}
