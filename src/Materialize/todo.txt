
TO DO! ********************************************




	Parser -> ParseStrategySource -> MapperRule -> MapperStrategy -> IModifier

	Parser -> ParseStrategySource -> MethodRule -> WhereStrategizer -> WhereOnClientStrategy -> IModifier
	


********************************************************************************************************
> Now we are transforming IQueryables it seems... so why don't we just rewrite expressions? Or rather, as that is exactly
	what we are doing... we could get client-side transformation query by snooping on EnumerableQuery populated by mapping.

	to do this, collectionfactory needs to somehow emplace a snooped EnumerableQuery each time...

	the outer mapstrategy does it, usually CollectionMap, though this isn't always the case!

	But, if the overall contraption yields an IQueryable, couldn't this just be sampled post facto?
	Would work, but not in case of unaries, which yield no IQueryable.

	Yet these limiting unaries are solely to do with parsing. The mapper IParseStrategy is therefore a likely spot
	to spy on the inner mapping machinery's yielded queryable.



	CollectionStrategy currently packages up all enumerables into new collections. Laudable.
	But this means eager realisation of source query... We are mapping from IQueryable to IQueryable:
	shouldn't there be a special mapping rule for this? I think this is very, very reasonable.

	If there were a special IQueryable collection rule, then the entire reification would become one big
	queryable chain, all the way through, and only realised at the last moment.

	But the problem with this lovely vision is that some clauses certainly can't be sent to the source server.

	We do need to realise in the middle. So all is currently well and good, except for the fact that Reifiable
	forces our results to a concrete enumerable, before passing to transformation! Transformation itself is
	supposed to achieve this.








**********************************************************************************************************


> In parsing, strategizers and rules are really at same level, have same function.
	Would seem neater to have specialised StrategyCondition classes - or *rules?*

> Changes of cardinality elsewhere are currently ignored in parsing

> Add T4 template to test project, will create 50 random queries, and test result against the same applied to an enumeration. These will all appear in test explorer, and will be refreshable. SourceRegime used should also be
  random (although this latter will give different results each time: not so good!)


> Should all would-be prependers of predicates to the source query be aware of clientside filtering?


> Split to new solution: AutoMapper.Piped
	Problem of git history...
	

> Only explicitly-marked properties should be treated as transitive.


> before-and-after hooks should only apply after all filtering done.


> Client-side filter predicates currently being compiled each time HORRIFIC!!!!!!
	need to parameterize and store with cache...
	This touches on the whole transformer-expression thing.



> Fancy demo project: OData! Info about each request...
	
> EF-mapped entities can't be projected to... need to do this client-side.
	- so, server-side projection that would normally be attempted should be checked with regime - if unacceptable, stick on client (this seems slow...)
	
> Ensure no static dictionaries about: ioc container should deal with this
  

> Test cache behaviour...

> Unary strategies must be sensitive to whether the set has been re-limited on the client:
	different strategies needed in this case 

> Test projection expressions for inputs. Use IProjectionInputDetector interface.

> How to hook in provider-specific extensions from other projects - needed to limit dependencies. 
	Surely has to be some configuration option, and type-gathering at initialization.

> Compiled little functions to cached by their expression trees

> Predicates to be split as much as possible to get as much on server as we can

